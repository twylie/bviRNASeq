#!/usr/bin/python3.7

# USAGE: ensembl_to_dataframes.py Homo_sapiens.GRCh38.cdna.all.fa

import sys
import re
from Bio import SeqIO
import pandas as pd


def parse_header_fields(line, sequence):

    # Some of the header fields may be blank. We evaluate for existence and set
    # the field to null if the field is blank in the header.

    if re.search(' description:', line):
        line, description = line.split(' description:')
    else:
        description = ''

    if re.search(' gene_symbol', line):
        line, gene_symbol = line.split(' gene_symbol:')
    else:
        gene_symbol = ''

    if re.search(' transcript_biotype:', line):
        line, transcript_biotype = line.split(' transcript_biotype:')
    else:
        transcript_biotype = ''

    if re.search(' gene_biotype:', line):
        line, gene_biotype = line.split(' gene_biotype:')
    else:
        gene_biotype = ''

    if re.search(' gene:', line):
        line, gene = line.split(' gene:')
    else:
        gene = ''

    transcript_id, seq_type, location = line.split(' ')

    header_fields = {
        'transcript_id': transcript_id,
        'seq_type': seq_type,
        'location': location,
        'gene': gene,
        'gene_biotype': gene_biotype,
        'transcript_biotype': transcript_biotype,
        'gene_symbol': gene_symbol,
        'description': description,
        'sequence': str(sequence)
    }

    return header_fields


def output_file_verbose_append(fh, header_fields):

    line = '\t'.join([
        header_fields['transcript_id'],
        header_fields['seq_type'],
        header_fields['location'],
        header_fields['gene'],
        header_fields['gene_biotype'],
        header_fields['transcript_biotype'],
        header_fields['gene_symbol'],
        header_fields['description'],
        header_fields['sequence']
    ])

    fh.write(line + '\n')

    return


def output_file_terse_append(fh, header_fields):

    line = '\t'.join([
        header_fields['transcript_id'],
        header_fields['seq_type'],
        header_fields['location'],
        header_fields['gene'],
        header_fields['gene_biotype'],
        header_fields['transcript_biotype'],
        header_fields['gene_symbol'],
        header_fields['description']
    ])

    fh.write(line + '\n')

    return


def output_file_verbose_set_header(fh):

    line = '\t'.join([
        'transcript_id',
        'seq_type',
        'location',
        'gene',
        'gene_biotype',
        'transcript_biotype',
        'gene_symbol',
        'description',
        'sequence',
    ])

    fh.write(line + '\n')

    return


def output_file_terse_set_header(fh):

    line = '\t'.join([
        'transcript_id',
        'seq_type',
        'location',
        'gene',
        'gene_biotype',
        'transcript_biotype',
        'gene_symbol',
        'description'
    ])

    fh.write(line + '\n')

    return


###############################################################################
#                                     MAIN                                    #
###############################################################################

# We're parsing the header fields from the cDNA FASTA file, as supplied by
# Ensembl. The headers contain annotation related to the associated sequence
# entries. Unfortunately, the headers are not particularly parser-friendly,
# provided that there are spaces in the description field, etc. Also, some the
# headers have blank entries for some of the fields. The parsing routine here
# takes these considerations into account. There will be two output files
# generated by this code: 1) tab-delimited version of the headers, including
# the sequence entry; 2) same output sans sequence entries.

# For more details on the header format, see:
# http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/cdna/README

# NOTE: The transcript_id field ids should be unique and may be used as an
# index downstream for the output files.

if __name__ == '__main__':

    transcriptome_fasta = sys.argv[1]

    output_file_verbose = '{}.verbose.tsv'.format(transcriptome_fasta)
    output_file_verbose_fh = open(output_file_verbose, 'w')
    output_file_verbose_set_header(output_file_verbose_fh)

    output_file_terse = '{}.terse.tsv'.format(transcriptome_fasta)
    output_file_terse_fh = open(output_file_terse, 'w')
    output_file_terse_set_header(output_file_terse_fh)

    # Write the tab-delimited versions of the files.

    with open(transcriptome_fasta, 'r') as fh:
        for record in SeqIO.parse(fh, "fasta"):
            header_fields = parse_header_fields(record.description, record.seq)
            output_file_verbose_append(output_file_verbose_fh, header_fields)
            output_file_terse_append(output_file_terse_fh, header_fields)

    output_file_verbose_fh.close()
    output_file_terse_fh.close()

    # Make Pandas-ready dataframe versions of the files, too. Index on
    # the unique transcipt_id fields and sort the index.

    output_file_df_verbose = '{}.verbose.DF.tsv'.format(transcriptome_fasta)
    df_verbose = pd.read_csv(output_file_verbose, sep='\t', index_col='transcript_id')
    df_verbose.sort_index(inplace=True)
    df_verbose.to_csv(output_file_df_verbose, sep='\t')

    output_file_df_terse = '{}.terse.DF.tsv'.format(transcriptome_fasta)
    df_terse = pd.read_csv(output_file_terse, sep='\t', index_col='transcript_id')
    df_terse.sort_index(inplace=True)
    df_terse.to_csv(output_file_df_terse, sep='\t')

# __END__
